## 1.首先
  - 把文件夹建好后 下载element-ui 插件  yarn add vue-cli-plugin-element 和 cnpm install element-ui ---save  
  - 安装axios 运行依赖
## 2. 把项目中无用的东西删除  
  **如果要自定义端口  在根目录下创建vue.config.js文件**
```html
  module.exports = {
  devServer: {
    // 端口
    port: 3000
  },
  lintOnSave: false // 取消 eslint 验证
}
```
  - 在main.js中引入axios 并且添加接口基准地址
    - axios.defaults.baseURL = `http://127.0.0.1:8888/api/private/v1/`
## 写login页面
 - 在commponents文件夹中建Login.vue 
 - 在路由中设置路由规则并且引入
 - 在App.vue中添加路由占位符
 - 然后写css样式渲染页面 写全局样式后 要把css导入main.js中
 - 用element-ui组件库 渲染页面
 - 导入font 字体图标文件夹  要现在入口文件引入css  再根据要求渲染
 - 在main.js中去挂载axios： Vue.prototype.$http = axios;
 - 全局挂载：Vue.prototype.$message = Message;
在login.vue组件中编写弹窗代码：this.$message.error('登录失败')
 - 点击登陆的时候先调用validate方法验证表单填写是否有误
 - 需要将后台返回的token保存到sessionStorage中
   操作完毕之后，需要跳转到/home

## home
 - 新建一个home页 
 - 添加路由导航守卫
   ```html
   //  挂载路由导航守卫 to表示将要访问的路径，from表示从哪里来，next是下一个要做的操作
    router.beforeEach((to, from, next) => {
      if (to.path === '/login') {
        // 放行
        return next()
      }
      // 如果访问的不是登录界面 获取token
      const tokenStr = window.sessionStorage.getItem('token')
      if (!tokenStr) {
        return next('/login')
      }
      next()
    })
   ```
 - 实现退出功能
   - 先清空sessionStorage
   - 跳转到登陆界面
 - 设置axios拦截器
 - 请求侧边栏数据 使用双重for循环渲染
  
### 补充
- 处理ESLint警告
打开脚手架面板，查看警告信息
 - 默认情况下，ESLint和vscode格式化工具有冲突，需要添加配置文件解决冲突。
在项目根目录添加 .prettierrc 文件

```
{
    "semi":false,
    "singleQuote":true
}
```

 - 打开.eslintrc.js文件，禁用对 space-before-function-paren 的检查:

```
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    'space-before-function-paren' : 0
  },
```
### axios请求拦截器
后台除了登录接口之外，都需要token权限验证，我们可以通过添加axios请求拦截器来添加token，以保证拥有获取数据的权限
在main.js中添加代码，在将axios挂载到vue原型之前添加下面的代码

```
//请求在到达服务器之前，先会调用use中的这个回调函数来添加请求头信息
axios.interceptors.request.use(config=>{
  //为请求头对象，添加token验证的Authorization字段
  config.headers.Authorization = window.sessionStorage.getItem("token")
  return config
})
```
### 5.设置激活子菜单样式
- 通过更改el-menu的active-text-color属性可以设置侧边栏菜单中点击的激活项的文字颜色
- 通过更改菜单项模板（template）中的i标签的类名，可以将左侧菜单栏的图标进行设置，我们需要在项目中使用第三方字体图标
在数据中添加一个iconsObj：

```
iconsObj: {
        '125':'iconfont icon-user',
        '103':'iconfont icon-tijikongjian',
        '101':'iconfont icon-shangpin',
        '102':'iconfont icon-danju',
        '145':'iconfont icon-baobiao'
      }
```

然后将图标类名进行数据绑定，绑定iconsObj中的数据：

为了保持左侧菜单每次只能打开一个，显示其中的子菜单，我们可以在el-menu中添加一个属性unique-opened
或者也可以数据绑定进行设置(此时true认为是一个bool值，而不是字符串) :unique-opened="true"

### 制作侧边栏的伸缩功能
在菜单栏上方添加一个div

```
        <!-- 侧边栏,宽度根据是否折叠进行设置 -->
        <el-aside :width="isCollapse ? '64px':'200px'">
          <!-- 伸缩侧边栏按钮 -->
          <div class="toggle-button" @click="toggleCollapse">|||</div>
          <!-- 侧边栏菜单，:collapse="isCollapse"（设置折叠菜单为绑定的 isCollapse 值），:collapse-transition="false"（关闭默认的折叠动画） -->
          <el-menu
          :collapse="isCollapse"
          :collapse-transition="false"
          ......
```

然后给div添加样式，给div添加事件：
```
<div class="toggle-button" @click="this.isCollapse ? '64px':'200px'">|||</div>
```
### 创建一个welcome页面
  在路由中添加规则
  - 制作好了Welcome子级路由之后，我们需要将所有的侧边栏二级菜单都改造成子级路由链接
  - 我们只需要将el-menu的router属性设置为true就可以了，此时当我们点击二级菜单的时候，就会根据菜单的index
   属性进行路由跳转,如: /110,
  - 使用index id来作为跳转的路径不合适，我们可以重新绑定index的值为  :index="'/'+subItem.path"

### 二级菜单高亮
**在侧边栏中开启路由功能  加上 router 就好了**
当点击二级菜单的时候，被点击的二级子菜单并没有高亮，我们需要正在被使用的功能高亮显示
我们可以通过设置el-menu的default-active属性来设置当前激活菜单的index
但是default-active属性也不能写死，固定为某个菜单值
所以我们可以先给所有的二级菜单添加点击事件,并将path值作为方法的参数
@click="saveNavState('/'+subItem.path)"
在saveNavState方法中将path保存到sessionStorage中
saveNavState( path ){
  //点击二级菜单的时候保存被点击的二级菜单信息
  window.sessionStorage.setItem("activePath",path);
  this.activePath = path;
}
然后在数据中添加一个activePath绑定数据，并将el-menu的default-active属性设置为activePath
最后在created中将sessionStorage中的数据赋值给activePath
this.activePath = window.sessionStorage.getItem("activePath")

## 绘制用户列表的基本结构
- 使用element-ui面包屑组件完成顶部导航路径(复制面包屑代码
- 使用element-ui卡片组件完成主体表格
 - 此时我们需要使用栅格布局来划分结构


### 实现搜索功能
添加数据绑定，添加搜索按钮的点击事件(当用户点击搜索按钮的时候，调用getUserList方法根据文本框内容重新请求用户列表数据)
当我们在输入框中输入内容并点击搜索之后，会按照搜索关键字搜索，我们希望能够提供一个X删除搜索关键字并重新获取所有的用户列表数据，只需要给文本框添加clearable属性并添加clear事件，在clear事件中重新请求数据即可

```
<el-col :span="7">
    <el-input placeholder="请输入内容" v-model="queryInfo.query" clearable @clear="getUserList">
        <el-button slot="append" icon="el-icon-search" @click="getUserList"></el-button>
    </el-input>
</el-col>
```

### 验证邮箱规则
```
 //验证邮箱的规则
  var checkEmail = (rule, value, cb) => {
    const regEmail = /^\w+@\w+(\.\w+)+$/
    if (regEmail.test(value)) {
      return cb()
    }
    //返回一个错误提示
    cb(new Error('请输入合法的邮箱'))
  }
  //验证手机号码的规则
  var checkMobile = (rule, value, cb) => {
    const regMobile = /^1[34578]\d{9}$/
    if (regMobile.test(value)) {
      return cb()
    }
    //返回一个错误提示
    cb(new Error('请输入合法的手机号码'))
  }
  ```
### 当关闭对话框时，重置表单
给el-dialog添加@close事件，在事件中添加重置表单的代码
```
methods:{
  ....
  addDialogClosed(){
      //对话框关闭之后，重置表达
      this.$refs.addFormRef.resetFields();
  }
}

```


### 点击对话框中的确定按钮，发送请求完成添加用户的操作
首先给确定按钮添加点击事件，在点击事件中完成业务逻辑代码
